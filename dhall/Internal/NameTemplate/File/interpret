let Case =
        ../Case sha256:9e2d5a3c338b63a4e067de578f9e65952648ed6ffcf4ee0caaa211cdb2b3a3c5
      ? ../Case

let Component =
        ./Component sha256:732fac7da6b8aa13bed3aff6440a17d342eab111607cc4e4454454003b287eda
      ? ./Component

let Interpret =
        ../Interpret sha256:da352ee981f47618957222659071fb284597087a51e9426729b3fde383c77a91
      ? ../Interpret

let Predicate =
        ../../Predicate/Type sha256:39e210b82052eda7f6cd4814c3d907c727b2ebea1c3c135957eef943014b46e9
      ? ../../Predicate/Type

let Tag =
        ../../Tag/Type sha256:3791aa7a52b92db3877472c57cec53ca856858bbad81156ef1bf29e9aeb2baee
      ? ../../Tag/Type

in  λ(interpret : Interpret) →
    λ(component : Component) →
    λ(Component : Type) →
      let ComponentF =
            < FileDuplicateNumberF
            | FileFormatAsF : { componentF : Component, formatCaseF : Case }
            | FileIfDuplicateF : { componentsF : List Component }
            | FileIfThenElseF :
                { predicateF : Predicate
                , trueComponentsF : List Component
                , falseComponentsF : List Component
                }
            | FileInterpretF :
                { componentF : Component, interpretAsF : Interpret }
            | FileOriginalNameF
            | FileTagValueF : Tag
            | FileTextLiteralF : Text
            >

      in  λ(Fix : ComponentF → Component) →
            Fix
              ( ComponentF.FileInterpretF
                  { componentF = component Component Fix
                  , interpretAsF = interpret
                  }
              )
